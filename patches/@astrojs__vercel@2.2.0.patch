diff --git a/dist/lib/nft.js b/dist/lib/nft.js
index 380de7537d17a8f1cc6d74fd5b8bf547a367cc1d..c997e85df468b56c934263ce2080ffc778a572df 100644
--- a/dist/lib/nft.js
+++ b/dist/lib/nft.js
@@ -1,23 +1,23 @@
-import { nodeFileTrace } from "@vercel/nft";
-import * as fs from "node:fs/promises";
-import nodePath from "node:path";
-import { fileURLToPath } from "node:url";
+import { nodeFileTrace } from '@vercel/nft';
+import * as fs from 'node:fs/promises';
+import nodePath from 'node:path';
+import { fileURLToPath } from 'node:url';
 async function copyDependenciesToFunction(entry, outDir) {
   const entryPath = fileURLToPath(entry);
   let base = entry;
-  while (fileURLToPath(base) !== fileURLToPath(new URL("../", base))) {
-    base = new URL("../", base);
+  while (fileURLToPath(base) !== fileURLToPath(new URL('../', base))) {
+    base = new URL('../', base);
   }
   const result = await nodeFileTrace([entryPath], {
-    base: fileURLToPath(base)
+    base: fileURLToPath(base),
   });
   if (result.fileList.size === 0)
-    throw new Error("[@astrojs/vercel] No files found");
+    throw new Error('[@astrojs/vercel] No files found');
   for (const error of result.warnings) {
-    if (error.message.startsWith("Failed to resolve dependency")) {
-      const [, module, file] = /Cannot find module '(.+?)' loaded from (.+)/.exec(error.message);
-      if (module === "@astrojs/")
-        continue;
+    if (error.message.startsWith('Failed to resolve dependency')) {
+      const [, module, file] =
+        /Cannot find module '(.+?)' loaded from (.+)/.exec(error.message);
+      if (module === '@astrojs/') continue;
       if (entryPath === file) {
         console.warn(
           `[@astrojs/vercel] The module "${module}" couldn't be resolved. This may not be a problem, but it's worth checking.`
@@ -27,6 +27,11 @@ async function copyDependenciesToFunction(entry, outDir) {
           `[@astrojs/vercel] The module "${module}" inside the file "${file}" couldn't be resolved. This may not be a problem, but it's worth checking.`
         );
       }
+    } else if (error.message.startsWith('Failed to parse')) {
+      const [, file] = /Failed to parse (.+)/.exec(error.message);
+      console.warn(
+        `[@astrojs/vercel] The file "${file}" couldn't be parsed. This may not be a problem, but it's worth checking.`
+      );
     } else {
       throw error;
     }
@@ -45,30 +50,34 @@ async function copyDependenciesToFunction(entry, outDir) {
     const isSymlink = realpath !== fileURLToPath(origin);
     const isDir = (await fs.stat(origin)).isDirectory();
     if (isDir && !isSymlink) {
-      await fs.mkdir(new URL("..", dest), { recursive: true });
+      await fs.mkdir(new URL('..', dest), { recursive: true });
     } else {
-      await fs.mkdir(new URL(".", dest), { recursive: true });
+      await fs.mkdir(new URL('.', dest), { recursive: true });
     }
     if (isSymlink) {
       const realdest = fileURLToPath(
         new URL(
-          nodePath.relative(nodePath.join(fileURLToPath(base), commonAncestor), realpath),
+          nodePath.relative(
+            nodePath.join(fileURLToPath(base), commonAncestor),
+            realpath
+          ),
           outDir
         )
       );
       await fs.symlink(
-        nodePath.relative(fileURLToPath(new URL(".", dest)), realdest),
+        nodePath.relative(fileURLToPath(new URL('.', dest)), realdest),
         dest,
-        isDir ? "dir" : "file"
+        isDir ? 'dir' : 'file'
       );
     } else if (!isDir) {
       await fs.copyFile(origin, dest);
     }
   }
   return {
-    handler: nodePath.relative(nodePath.join(fileURLToPath(base), commonAncestor), entryPath)
+    handler: nodePath.relative(
+      nodePath.join(fileURLToPath(base), commonAncestor),
+      entryPath
+    ),
   };
 }
-export {
-  copyDependenciesToFunction
-};
+export { copyDependenciesToFunction };
diff --git a/src/lib/nft.ts b/src/lib/nft.ts
index ba36775837787caca44189c296f768372021cea4..5335df06a6a231ee9cf45dcee2719b5cc9b190af 100644
--- a/src/lib/nft.ts
+++ b/src/lib/nft.ts
@@ -4,87 +4,101 @@ import nodePath from 'node:path';
 import { fileURLToPath } from 'node:url';
 
 export async function copyDependenciesToFunction(
-	entry: URL,
-	outDir: URL
+  entry: URL,
+  outDir: URL
 ): Promise<{ handler: string }> {
-	const entryPath = fileURLToPath(entry);
+  const entryPath = fileURLToPath(entry);
 
-	// Get root of folder of the system (like C:\ on Windows or / on Linux)
-	let base = entry;
-	while (fileURLToPath(base) !== fileURLToPath(new URL('../', base))) {
-		base = new URL('../', base);
-	}
+  // Get root of folder of the system (like C:\ on Windows or / on Linux)
+  let base = entry;
+  while (fileURLToPath(base) !== fileURLToPath(new URL('../', base))) {
+    base = new URL('../', base);
+  }
 
-	const result = await nodeFileTrace([entryPath], {
-		base: fileURLToPath(base),
-	});
+  const result = await nodeFileTrace([entryPath], {
+    base: fileURLToPath(base),
+  });
 
-	if (result.fileList.size === 0) throw new Error('[@astrojs/vercel] No files found');
+  if (result.fileList.size === 0)
+    throw new Error('[@astrojs/vercel] No files found');
 
-	for (const error of result.warnings) {
-		if (error.message.startsWith('Failed to resolve dependency')) {
-			const [, module, file] = /Cannot find module '(.+?)' loaded from (.+)/.exec(error.message)!;
+  for (const error of result.warnings) {
+    if (error.message.startsWith('Failed to resolve dependency')) {
+      const [, module, file] =
+        /Cannot find module '(.+?)' loaded from (.+)/.exec(error.message)!;
 
-			// The import(astroRemark) sometimes fails to resolve, but it's not a problem
-			if (module === '@astrojs/') continue;
+      // The import(astroRemark) sometimes fails to resolve, but it's not a problem
+      if (module === '@astrojs/') continue;
 
-			if (entryPath === file) {
-				console.warn(
-					`[@astrojs/vercel] The module "${module}" couldn't be resolved. This may not be a problem, but it's worth checking.`
-				);
-			} else {
-				console.warn(
-					`[@astrojs/vercel] The module "${module}" inside the file "${file}" couldn't be resolved. This may not be a problem, but it's worth checking.`
-				);
-			}
-		} else {
-			throw error;
-		}
-	}
+      if (entryPath === file) {
+        console.warn(
+          `[@astrojs/vercel] The module "${module}" couldn't be resolved. This may not be a problem, but it's worth checking.`
+        );
+      } else {
+        console.warn(
+          `[@astrojs/vercel] The module "${module}" inside the file "${file}" couldn't be resolved. This may not be a problem, but it's worth checking.`
+        );
+      }
+    } else if (error.message.startsWith('Failed to parse')) {
+      const [, file] = /Failed to parse (.+)/.exec(error.message)!;
 
-	const fileList = [...result.fileList];
+      console.warn(
+        `[@astrojs/vercel] The file "${file}" couldn't be parsed. This may not be a problem, but it's worth checking.`
+      );
+    } else {
+      throw error;
+    }
+  }
 
-	let commonAncestor = nodePath.dirname(fileList[0]);
-	for (const file of fileList.slice(1)) {
-		while (!file.startsWith(commonAncestor)) {
-			commonAncestor = nodePath.dirname(commonAncestor);
-		}
-	}
+  const fileList = [...result.fileList];
 
-	for (const file of fileList) {
-		const origin = new URL(file, base);
-		const dest = new URL(nodePath.relative(commonAncestor, file), outDir);
+  let commonAncestor = nodePath.dirname(fileList[0]);
+  for (const file of fileList.slice(1)) {
+    while (!file.startsWith(commonAncestor)) {
+      commonAncestor = nodePath.dirname(commonAncestor);
+    }
+  }
 
-		const realpath = await fs.realpath(origin);
-		const isSymlink = realpath !== fileURLToPath(origin);
-		const isDir = (await fs.stat(origin)).isDirectory();
+  for (const file of fileList) {
+    const origin = new URL(file, base);
+    const dest = new URL(nodePath.relative(commonAncestor, file), outDir);
 
-		// Create directories recursively
-		if (isDir && !isSymlink) {
-			await fs.mkdir(new URL('..', dest), { recursive: true });
-		} else {
-			await fs.mkdir(new URL('.', dest), { recursive: true });
-		}
+    const realpath = await fs.realpath(origin);
+    const isSymlink = realpath !== fileURLToPath(origin);
+    const isDir = (await fs.stat(origin)).isDirectory();
 
-		if (isSymlink) {
-			const realdest = fileURLToPath(
-				new URL(
-					nodePath.relative(nodePath.join(fileURLToPath(base), commonAncestor), realpath),
-					outDir
-				)
-			);
-			await fs.symlink(
-				nodePath.relative(fileURLToPath(new URL('.', dest)), realdest),
-				dest,
-				isDir ? 'dir' : 'file'
-			);
-		} else if (!isDir) {
-			await fs.copyFile(origin, dest);
-		}
-	}
+    // Create directories recursively
+    if (isDir && !isSymlink) {
+      await fs.mkdir(new URL('..', dest), { recursive: true });
+    } else {
+      await fs.mkdir(new URL('.', dest), { recursive: true });
+    }
 
-	return {
-		// serverEntry location inside the outDir
-		handler: nodePath.relative(nodePath.join(fileURLToPath(base), commonAncestor), entryPath),
-	};
+    if (isSymlink) {
+      const realdest = fileURLToPath(
+        new URL(
+          nodePath.relative(
+            nodePath.join(fileURLToPath(base), commonAncestor),
+            realpath
+          ),
+          outDir
+        )
+      );
+      await fs.symlink(
+        nodePath.relative(fileURLToPath(new URL('.', dest)), realdest),
+        dest,
+        isDir ? 'dir' : 'file'
+      );
+    } else if (!isDir) {
+      await fs.copyFile(origin, dest);
+    }
+  }
+
+  return {
+    // serverEntry location inside the outDir
+    handler: nodePath.relative(
+      nodePath.join(fileURLToPath(base), commonAncestor),
+      entryPath
+    ),
+  };
 }